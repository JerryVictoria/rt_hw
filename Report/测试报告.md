# 测试报告

## 1 测试应用设计简述

### 1.1 调度算法测试结果展示

分别针对每个算法设计了测试用例，以表现算法运行结果。

#### 1.1.1 抢占式优先级调度

测试代码位于`example/policy-prio-testcase`文件夹下。

有两个线程：

1. job1 -- priority=30 period=4 time_capacity=2
2. job2 -- priority=40 period=4 time_capacity=2

先创建job1再创建job2。但由于job2优先级更高，只有当job2执行完并等待下一次job2周期任务到来这段时间内，且job1处于可运行状态下，job1可以执行。

运行结果如下：

```
[P1] pok_thread_create (job1) return=0
[P1] pok_thread_create (job2) return=0
BBABBABBABBABBA……
```

#### 1.1.2 抢占式EDF调度

测试代码位于`example/policy-edf-testcase`文件夹下。

有三个线程（每个线程在只打印字母，无其他操作）：

| Thread | period  | deadline |
| :----: | :-----: | :------: |
|   T1   | 2000000 | 1000000  |
|   T2   | 1000000 |  500000  |
|   T3   | 1000000 |  200000  |

运行结果如下：

```
[P1] pok_thread_create (1) return=0
[P1] pok_thread_create (2) return=0
[P1] pok_thread_create (3) return=0
T3 T2 T1 T3 T2 T3 T2 T1 T3 T2 T3 T2 T1 ……
```

#### 1.1.3 Round-Robin调度

测试代码位于`example/policy-rr-testcase`文件夹下。

有三个线程，每个线程只打印字母，每个线程对应的时间片（time_capacity）如下

1. Thread1 --  time_capacity 1
2. Thread2 --  time_capacity 2
3. Thread3 --  time_capacity 3

运行结果如下:

```
[P1] pok_thread_create (1) return=0
[P1] pok_thread_create (2) return=0
[P1] pok_thread_create (3) return=0
T1 T2 T2 T3 T3 T3 T1 T2 T2 T3 T3 T3 
```

#### 1.1.4 Weighted-Round-Robin调度

测试代码位于`example/policy-wrr-testcase`文件夹下。

三种线程（每个线程只打印字母，无其他操作）：

1. jobA4 -- weight = 4
2. jobB3 -- weight = 3
3. jobC2 -- weight = 2

运行结果如下：

```
[P1] pok_thread_create (1) return=0
[P1] pok_thread_create (2) return=0
[P1] pok_thread_create (3) return=0
AABABCABC
AABABCABC
AABABCABC
AABABCABC
AABABCABC
AABABCABC
AABABCABC
AABABCABC
AABABCABC
AABABCABC
```

### 1.2 场景设计

一共有五道菜，面包、炸鸡、汉堡、汤、面条。汉堡的制作需要面包和炸鸡。

从程序角度来说，汉堡线程需要等待两个信号量，一个由面包线程释放，一个由炸鸡线程释放。汤线程和面条线程属于两道独立的线程，不受任何其他线程影响，同时也不对其他线程造成影响。

五道菜的线程参数如下表所示：

| param (related_policy) | bread(A) | fried_chicken(B) | hamburger(C) | soup(D) | noodle(E) |
| ---------------------- | -------- | ---------------- | ------------ | ------- | --------- |
| weight (WRR)           | 5        | 5                | 3            | 2       | 4         |
| priority (PRIO)        | 10       | 10               | 5            | 6       | 7         |
| period                 | 9        | 9                | 8            | 8       | 5         |
| execuation_time        | 1        | 2                | 1            | 2       | 1         |
| deadline               | 2        | 3                | 7            | 8       | 5         |
| time_capacity          | 1        | 2                | 1            | 2       | 1         |

注：这里的一个单位等于一次调度的间隔时间

**实际设计**

根据实际运行结果来看，一次调度时间为9,219,000，所以设计参数时，应该考虑实际调度时间

## 2 不同调度算法应用结果

### 2.1 抢占式优先级调度

#### 2.1.1 理论值

理论上，不考虑启动时间、信号量依赖导致的线程上下文切换，应该结果如下：

|                      | 0     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------------------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **bread(A)**         | √     |      |      |      |      |      |      |      |      | √    |      |
| **fried_chicken(B)** |       | √    | √    |      |      |      |      |      |      |      | √    |
| **hamburger(C)**     |       |      |      |      |      |      |      | √    |      |      |      |
| **soup(D)**          |       |      |      |      | √    |      | √    |      | √    |      |      |
| **noodle(E)**        |       |      |      | √    |      | √    |      |      |      |      |      |
| **All Tasks**        | ABCDE | BCDE | BCDE | CDE  | CD   | CDE  | CD   | C    | CD   | ABCD | BCDE |

#### 2.1.2 任务无依赖

如果不考虑信号量，实际测试运行的结果为：

```
time: 9809016, now: 1, A
time: 18438000, now: 2, B
time: 27657000, now: 3, B
time: 36876000, now: 4, E
time: 46095000, now: 5, D
time: 55314000, now: 6, E
time: 64533000, now: 7, D
time: 73752000, now: 8, C
time: 82971000, now: 9, A
time: 92190000, now: 10, B
time: 101409000, now: 11, B
time: 110628000, now: 12, E
```

整理为表格如下：

|                      | 0    | 1     | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------------------- | ---- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **bread(A)**         |      | √     |      |      |      |      |      |      |      | √    |      |
| **fried_chicken(B)** |      |       | √    | √    |      |      |      |      |      |      | √    |
| **hamburger(C)**     |      |       |      |      |      |      |      |      | √    |      |      |
| **soup(D)**          |      |       |      |      |      | √    |      | √    |      |      |      |
| **noodle(E)**        |      |       |      |      | √    |      | √    |      |      |      |      |
| **All Tasks**        |      | ABCDE | BCDE | BCDE | CDE  | CD   | CDE  | CD   | C    | ABD  | BCDE |

这个结果与理论值**有部分出入**。

首先，由于程序有启动时间，故而时间节点0，没有线程可以调度，故而0~7的结果整体右移一个时间单位。

而时间节点8，虽然CD都是进入了下一轮周期，但是此时的D正好是上一个时间节点运行任务，且当时D的状态是可运行(runnable)状态，故而不会更新剩余运行时间。故而当进入时间节点8时，D变成`POK_STATE_WAIT_NEXT_ACTIVATION`状态，只有到下一个时间节点，才会重新恢复运行时间。所以此时间节点只有C可执行。同理时间节点9中的All Task没有任务C。

#### 2.1.3 任务有依赖

如果考虑信号量，实际测试运行的结果为：

```
time: 9799797, now: 1, A
time: 18438000, now: 2, B
time: 27657000, now: 3, B
time: 36876000, now: 4, E
time: 46095000, now: 5, D
time: 55314000, now: 6, E
time: 64533000, now: 7, D
time: 73752000, now: 8, C
time: 74065446, now: 8, D
time: 82971000, now: 9, A
time: 92190000, now: 10, B
time: 101409000, now: 11, B
time: 110628000, now: 12, E
```

整理为表格如下：

|                      | 1     | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 8    | 9    | 10   |
| -------------------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **bread(A)**         | √     |      |      |      |      |      |      |      |      | √    |      |
| **fried_chicken(B)** |       | √    | √    |      |      |      |      |      |      |      | √    |
| **hamburger(C)**     |       |      |      |      |      |      |      | √    |      |      |      |
| **soup(D)**          |       |      |      |      | √    |      | √    |      | √    |      |      |
| **noodle(E)**        |       |      |      | √    |      | √    |      |      |      |      |      |
| **All Tasks**        | ABCDE | BCDE | BCDE | CDE  | CD   | CDE  | CD   | C    | CD   | ABCD | BCDE |

这个结果与理论**基本一致**，但是**原因并不是**此种执行是按理论执行的。

由于pok内核实现信号量释放时，会主动调用一次`pok_sched`，故在第二个时间节点8上并不存在上一种情况的问题。（通过打印数据中的time可以得知时间节点8上执行了两次sched操作）

### 2.2 抢占式EDF调度

#### 2.2.1 理论值

理论上，不考虑启动时间、信号量依赖导致的线程上下文切换，应该结果如下：

即：ABBECDDEDAB

|                      | 0     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------------------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **bread(A)**         | √     |      |      |      |      |      |      |      |      | √    |      |
| **fried_chicken(B)** |       | √    | √    |      |      |      |      |      |      |      | √    |
| **hamburger(C)**     |       |      |      |      | √    |      |      |      |      |      |      |
| **soup(D)**          |       |      |      |      |      | √    | √    |      | √    |      |      |
| **noodle(E)**        |       |      |      | √    |      |      |      | √    |      |      |      |
| **All Tasks**        | ABCDE | BCDE | BCDE | CDE  | CD   | DE   | DE   | E    | CD   | ABD  | BDE  |

#### 2.2.2 任务无依赖

执行结果如下：

```
time: 9790578, now: 1, A
time: 18438000, now: 2, B
time: 27657000, now: 3, B
time: 36876000, now: 4, E
time: 46095000, now: 5, C
time: 55314000, now: 6, D
time: 64533000, now: 7, D
time: 73752000, now: 8, E
time: 82971000, now: 9, A
time: 92190000, now: 10, B
```

这个结果与理论值**有部分出入**，产生差异的原因和抢占式优先级调度的原因相似。

首先，由于程序有启动时间，故而时间节点0，没有线程可以调度，故而0~7的结果整体右移一个时间单位。时间节点8时，CD进入下一个周期，但是D是上一个时间节点运行任务，且当时D的状态是可运行(runnable)状态，故而不会更新剩余运行时间。故而当进入时间节点8时，D变成`POK_STATE_WAIT_NEXT_ACTIVATION`状态，只有到下一个时间节点，才会重新恢复运行时间，而下一个时间节点AB已经重新激活，且deadline更早，因此执行A。

#### 2.2.3 任务有依赖

执行结果如下：

```
time: 9910425, now: 1, A
time: 18438000, now: 2, B
time: 27657000, now: 3, B
time: 36876000, now: 4, E
time: 46095000, now: 5, C
time: 46445322, now: 5, D
time: 55314000, now: 6, D
time: 64533000, now: 7, E
time: 73752000, now: 8, C
time: 73752000, now: 8, D
time: 82971000, now: 9, A
time: 92190000, now: 10, B
```

结果与理论值基本一致，在pok实现的内核中，实现信号量机制时会主动调度一次pok_sched()，可以看到结果中两次now : 8，由于C需要等待A和B释放的信号量，因此多了一次调度，执行D。

### 2.3 Round-Robin调度

#### 2.3.1 理论值

理论上，不考虑启动时间、信号量依赖导致的线程上下文切换，应该结果如下：

|                      | 0     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| -------------------- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **bread(A)**         | √     |      |      |      |      |      |      |      |      |      |      |
| **fried_chicken(B)** |       | √    | √    |      |      |      |      |      |      |      |      |
| **hamburger(C)**     |       |      |      | √    |      |      |      |      | √    |      |      |
| **soup(D)**          |       |      |      |      | √    | √    |      |      |      | √    | √    |
| **noodle(E)**        |       |      |      |      |      |      | √    |      |      |      |      |
| **All Tasks**        | ABCDE | BCDE | BCDE | CDE  | DE   | DE   | E    | -    | CDE  | ABDE | ABDE |

#### 2.3.2 任务无依赖

如果不考虑信号量，实际测试运行的结果为：

```
time: 9891987, now: 1, A
time: 18438000, now: 2, B
time: 27657000, now: 3, B
time: 36876000, now: 4, C
time: 46095000, now: 5, D
time: 55314000, now: 6, D
time: 64533000, now: 7, E
time: 73752000, now: 8, C
time: 82971000, now: 9, D
time: 92190000, now: 10, D
```

与理论值调度结果基本一致。

#### 2.3.3 任务有依赖

```
time: 9974958, now: 1, A
time: 18438000, now: 2, B
time: 27657000, now: 3, B
time: 36876000, now: 4, C
time: 37475235, now: 4, D
time: 46095000, now: 5, D
time: 55314000, now: 6, E
time: 64533000, now: 7, IDLE THREAD
time: 73752000, now: 8, C
time: 73752000, now: 8, D
time: 82971000, now: 9, D
```

这个结果与理论**基本一致**。

由于pok内核实现信号量释放时，会主动调用一次`pok_sched`，通过打印数据中的time可以得知时间节点8上执行了两次sched操作。

### 2.4 Weighted-Round-Robin调度

该算法根据参考资料所实现，不受period影响，理解为所有任务一直都能被选择，如果任务执行结束，则理解为任务占用了CPU时间却不需要实际工作。

#### 2.4.1 理论值

|         | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13           |14|15|16|17|18|
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ------------ |--|--|--|--|--|
| Task    | A    | B    | A    | B    | E    | A    | B    | C | E |A | B |C |D |E |A |B |C |D |E |
| Working | 1    | 1    | 0    | 1    | 1   | 0    | 0    | 1   | 1   | 1   | 1   | 1 | 1 | 1 |0|1|1|1|1|

#### 2.4.2 任务无依赖

如果不考虑信号量，实际测试运行的结果为：

```
time: 9827454, now: 1, A
time: 18438000, now: 2, B
time: 27657000, now: 3, A
time: 36876000, now: 4, B
time: 46095000, now: 5, E
time: 55314000, now: 6, A
time: 64533000, now: 7, B
time: 73752000, now: 8, C
time: 82971000, now: 9, E
time: 92190000, now: 10, A
time: 101409000, now: 11, B
time: 110628000, now: 12, C
time: 119847000, now: 13, D
time: 129066000, now: 14, E
time: 138285000, now: 15, A
time: 147504000, now: 16, B
time: 156723000, now: 17, C
time: 165942000, now: 18, D
time: 175161000, now: 19, E
```

整理为表格如下：

|         | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   | 17   | 18   |19|
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |--|
| Task    || A    | B    | A    | B    | E    | A    | B    | C    | E    | A    | B    | C    | D    | E    | A    | B    | C    | D    | E    |
| Working || 1    | 1    | 0    | 1    | 1    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 0    | 1    | 1    | 1    | 1    |

和理论**基本一致**，由于程序有启动时间，故而时间节点0，没有线程可以调度，故而0~18的结果整体右移一个时间单位。

#### 2.4.3 任务有依赖

如果考虑信号量，实际测试运行的结果为：

```
time: 9799797, now: 1, A
time: 18438000, now: 2, B
time: 27657000, now: 3, A
time: 36876000, now: 4, B
time: 46095000, now: 5, E
time: 55314000, now: 6, A
time: 64533000, now: 7, B
time: 73752000, now: 8, C
time: 74028570, now: 8, E
time: 82971000, now: 9, A
time: 92190000, now: 10, B
time: 101409000, now: 11, C
time: 101611818, now: 11, D
time: 110628000, now: 12, E
time: 119847000, now: 13, A
time: 129066000, now: 14, B
time: 138285000, now: 15, C
time: 138515475, now: 15, D
time: 147504000, now: 16, E
```

整理为表格如下：

|         | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 8    | 9    | 10   | 11   | 11   | 12   | 13   | 14   | 15    | 15   | 16   |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ----- | ---- | ---- |
| Task    |      | A    | B    | A    | B    | E    | A    | B    | C    | E    | A    | B    | C    | D    | E    | A    | B    | C     | D    | E    |
| Working |      | 1    | 1    | 0    | 1    | 1    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 0    | 1    | **0** | 1    | 1    |

和理论**基本一致**，由于程序有启动时间，故而时间节点0，没有线程可以调度，故而0~18的结果整体右移一个时间单位，但是释放信号量会主动调用sched，所以线程切换更快。但是，这有可能会导致更多的任务线程占用CPU而不做任何工作（如例子中的时间节点15上的TaskC），也可能会出现因为部分线程能够有效利用CPU时间并在DDL前完成工作的情况。

## 3 不同调度算法应用简单比较

### 3.1 抢占式优先级调度

优先级调度保证了优先级最高的任务能够最快执行，但如果优先级设置不佳，可能会导致过多的deadline miss。

设置不佳的情况有以下两种：

1. 对于有依赖的任务A、任务B，如果任务B依赖于任务A，且任务B的优先级更高，则会导致时间片的浪费
2. 对于周期较短、优先级很高的任务A，周期较长、优先级很低的任务B，如果任务B总是被A抢占CPU时间，很可能导致任务B错过deadline

### 3.2 抢占式EDF调度

EDF调度算法依赖于任务的绝对deadline，在每次调度时选择当前所以可以运行的任务中最早截止时间的任务，以尽可能减少deadline miss的次数。任务的绝对deadline取决于到达周期period和在每个周期中的相对deadline，如果任务集是可调度的，那么EDF调度算法一定是可调度的。

### 3.3 Round-Robin调度

在pok内核实现的Round-Robin调度算法保证了每个任务在time_capacity被用完时，让出执行权，不会出现由于先前的任务过长而导致的后续任务过多的deadline miss。

### 3.4 Weighted-Round-Robin调度

该调度算法只依赖于weight属性，属性越大的任务能够被调度的次数就越多。因此，对于本文中的场景来说，此策略并不合适。任务的调度完全会由weight影响，最终是否能够在deadline前完成，只取决于初始化时，weight的设置以及任务发布的顺序。

该算法比较适用于分配服务器响应的问题。当一个服务器当前响应能力较强时，会优先选择此服务器进行服务。如果对应于任务调度，可能是

- 当前任务需要的时间较多时，优先服务当前任务
- 当前任务优先级较高时，优先服务当前任务（适用于优先级是动态的情况）